; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\hw_config.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -ID:\Keil5\ARM\RV31\INC -ID:\Keil5\ARM\CMSIS\Include -ID:\Keil5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\hw_config.crf ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;170    *******************************************************************************/
;;;171    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L1.8|
;;;172    {
;;;173      /* Set the device state to suspend */
;;;174      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;175    }
000006  4770              BX       lr
;;;176    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;345    *******************************************************************************/
;;;346    void Get_SerialNum(void)
000000  480a              LDR      r0,|L2.44|
;;;347    {
000002  b510              PUSH     {r4,lr}
;;;348      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;349    
;;;350      Device_Serial0 = *(uint32_t*)ID1;
;;;351      Device_Serial1 = *(uint32_t*)ID2;
000004  6801              LDR      r1,[r0,#0]
000006  1d00              ADDS     r0,r0,#4
;;;352      Device_Serial2 = *(uint32_t*)ID3;   
000008  6804              LDR      r4,[r0,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
;;;353    
;;;354      Device_Serial0 += Device_Serial2;
00000e  1808              ADDS     r0,r1,r0
000010  d00b              BEQ      |L2.42|
;;;355    
;;;356      if (Device_Serial0 != 0)
;;;357      {
;;;358        IntToUnicode (Device_Serial0, &DFU_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L2.48|
000016  f7fffffe          BL       IntToUnicode
;;;359        IntToUnicode (Device_Serial1, &DFU_StringSerial[18], 4);
00001a  4905              LDR      r1,|L2.48|
00001c  4620              MOV      r0,r4
00001e  2204              MOVS     r2,#4
000020  e8bd4010          POP      {r4,lr}
000024  3110              ADDS     r1,r1,#0x10
000026  f7ffbffe          B.W      IntToUnicode
                  |L2.42|
;;;360      }
;;;361    }
00002a  bd10              POP      {r4,pc}
;;;362    
                          ENDP

                  |L2.44|
                          DCD      0x1ffff7e8
                  |L2.48|
                          DCD      DFU_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;369    *******************************************************************************/
;;;370    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;371    {
;;;372      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;373      
;;;374      for( idx = 0 ; idx < len ; idx ++)
;;;375      {
;;;376        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;377        {
;;;378          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;379        }
;;;380        else
;;;381        {
;;;382          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L3.50|
00000e  bf00              NOP                            ;376
                  |L3.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;376
000014  d902              BLS      |L3.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;378
00001a  e001              B        |L3.32|
                  |L3.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L3.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;383        }
;;;384        
;;;385        value = value << 4;
;;;386        
;;;387        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;385
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;374
                  |L3.50|
000032  4293              CMP      r3,r2                 ;374
000034  d3ec              BCC      |L3.16|
;;;388      }
;;;389    }
000036  bdf0              POP      {r4-r7,pc}
;;;390    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;183    *******************************************************************************/
;;;184    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L4.20|
;;;185    {
;;;186      DEVICE_INFO *pInfo = &Device_Info;
;;;187    
;;;188      /* Set the device state to the correct state */
;;;189      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;190      {
;;;191        /* Device configured */
;;;192        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L4.24|
000006  b109              CBZ      r1,|L4.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L4.14|
                  |L4.12|
;;;193      }
;;;194      else
;;;195      {
;;;196        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L4.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;197      }
;;;198      /*Enable SystemCoreClock*/
;;;199      SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;200    }
;;;201    
                          ENDP

                  |L4.20|
                          DCD      Device_Info
                  |L4.24|
                          DCD      bDeviceState

                          AREA ||i.Reset_Device||, CODE, READONLY, ALIGN=2

                  Reset_Device PROC
;;;332    *******************************************************************************/
;;;333    void Reset_Device(void)
000000  2000              MOVS     r0,#0
;;;334    {
;;;335      USB_Cable_Config(DISABLE);
000002  f7fffffe          BL       USB_Cable_Config
000006  f3bf8f4f          DSB      
00000a  4805              LDR      r0,|L5.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  4a05              LDR      r2,|L5.36|
000010  f40161e0          AND      r1,r1,#0x700
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
000018  f3bf8f4f          DSB      
                  |L5.28|
00001c  e7fe              B        |L5.28|
;;;336      NVIC_SystemReset();
;;;337    }
;;;338    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      0xe000ed0c
                  |L5.36|
                          DCD      0x05fa0004

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;54     *******************************************************************************/
;;;55     void Set_System(void)
000000  b538              PUSH     {r3-r5,lr}
;;;56     {
;;;57     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined (STM32L1XX_MD_PLUS)
;;;58       GPIO_InitTypeDef GPIO_InitStructure;
;;;59     #endif /* STM32L1XX_XD*/
;;;60       
;;;61       /*!< At this stage the microcontroller clock setting is already configured, 
;;;62            this is done through SystemInit() function which is called from startup
;;;63            file (startup_stm32f10x_xx.s) before to branch to application main.
;;;64            To reconfigure the default setting of SystemInit() function, refer to
;;;65            system_stm32f10x.c file
;;;66          */ 
;;;67       
;;;68     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;69       /* Enable the SYSCFG module clock */
;;;70       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;71     #endif /* STM32L1XX_XD */ 
;;;72       
;;;73       FLASH_Unlock();
000002  f7fffffe          BL       FLASH_Unlock
;;;74       
;;;75     #ifdef USE_STM3210E_EVAL
;;;76       /* Enable the FSMC Clock */
;;;77       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000006  2101              MOVS     r1,#1
000008  020c              LSLS     r4,r1,#8
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;78     #endif /* USE_STM3210E_EVAL */
;;;79     #if defined (USE_STM3210E_EVAL)
;;;80       /* Enable the FSMC Clock */
;;;81       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;82     #endif /* USE_STM3210E_EVAL */
;;;83         
;;;84     #if defined(STM32F37X) || defined(STM32F30X)
;;;85       /* Enable the USB disconnect GPIO clock */
;;;86       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;87     
;;;88      /*Set PA11,12 as IN - USB_DM,DP*/
;;;89       
;;;90       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;91       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;92       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;93       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;94       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;95       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;96       GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;97         
;;;98       /*SET PA11,12 for USB: USB_DM,DP*/
;;;99       GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;100      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;101     
;;;102      /* USB_DISCONNECT used as USB pull-up */
;;;103      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;104      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;105      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;106      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;107      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;108      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;109      
;;;110     /*Output low level on USB_Disconnect Pin to enable 1.5k ohm pull-up resistor*/
;;;111      GPIO_WriteBit(USB_DISCONNECT, USB_DISCONNECT_PIN, Bit_RESET);
;;;112    
;;;113    #endif /* STM32F37X && STM32F30X */
;;;114    
;;;115    #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)  && !defined(STM32F37X) && !defined(STM32F30X)
;;;116      /* Enable "DISCONNECT" GPIO clock */
;;;117      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
000018  2101              MOVS     r1,#1
00001a  2008              MOVS     r0,#8
00001c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;118      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
000020  2101              MOVS     r1,#1
000022  4608              MOV      r0,r1
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;119      GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
000028  2101              MOVS     r1,#1
00002a  4813              LDR      r0,|L6.120|
00002c  f7fffffe          BL       GPIO_PinRemapConfig
;;;120      
;;;121      /* Configure USB pull-up */
;;;122      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
000030  01a0              LSLS     r0,r4,#6
000032  f8ad0000          STRH     r0,[sp,#0]
;;;123      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000036  2003              MOVS     r0,#3
000038  f88d0002          STRB     r0,[sp,#2]
;;;124      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
00003c  2014              MOVS     r0,#0x14
00003e  f88d0003          STRB     r0,[sp,#3]
;;;125      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  480d              LDR      r0,|L6.124|
000046  f7fffffe          BL       GPIO_Init
;;;126    
;;;127      /* Disable the USB connection till initialization phase end */  
;;;128      USB_Cable_Config(DISABLE);
00004a  2000              MOVS     r0,#0
00004c  f7fffffe          BL       USB_Cable_Config
;;;129    #endif /* STM32L1XX_XD */
;;;130      
;;;131      /* Init the media interface */
;;;132      MAL_Init();
000050  f7fffffe          BL       MAL_Init
;;;133      USB_Cable_Config(ENABLE);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       USB_Cable_Config
;;;134      
;;;135      /* Configure the EXTI line 18 connected internally to the USB IP */
;;;136      EXTI_ClearITPendingBit(EXTI_Line18);
00005a  02a4              LSLS     r4,r4,#10
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;137      EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
000062  4907              LDR      r1,|L6.128|
;;;138      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000064  2008              MOVS     r0,#8
000066  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
000068  7148              STRB     r0,[r1,#5]
;;;139      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00006a  2001              MOVS     r0,#1
00006c  7188              STRB     r0,[r1,#6]
;;;140      EXTI_Init(&EXTI_InitStructure);
00006e  4608              MOV      r0,r1
000070  f7fffffe          BL       EXTI_Init
;;;141    }
000074  bd38              POP      {r3-r5,pc}
;;;142    
                          ENDP

000076  0000              DCW      0x0000
                  |L6.120|
                          DCD      0x00300200
                  |L6.124|
                          DCD      0x40010c00
                  |L6.128|
                          DCD      ||area_number.13||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;149    *******************************************************************************/
;;;150    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;153      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;154       
;;;155    #else 
;;;156      /* Select USBCLK source */
;;;157      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;158      
;;;159      /* Enable the USB clock */
;;;160      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;161    #endif /* STM32L1XX_MD */
;;;162    }
;;;163    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;208    *******************************************************************************/
;;;209    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;210    {
;;;211    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;212      if (NewState != DISABLE)
;;;213      {
;;;214        STM32L15_USB_CONNECT;
;;;215      }
;;;216      else
;;;217      {
;;;218        STM32L15_USB_DISCONNECT;
;;;219      }  
;;;220    #else 
;;;221      if (NewState == DISABLE)
000002  2800              CMP      r0,#0
;;;222      {
;;;223        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000004  f44f4180          MOV      r1,#0x4000
;;;224      }
;;;225      else
;;;226      {
;;;227        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L8.16|
00000c  f7ffbffe          B.W      GPIO_SetBits
                  |L8.16|
000010  f7ffbffe          B.W      GPIO_ResetBits
;;;228      }
;;;229    #endif /* STM32L1XX_XD */
;;;230    }
;;;231    
                          ENDP

                  |L8.20|
                          DCD      0x40010c00

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;274    *******************************************************************************/
;;;275    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;276    {
;;;277      NVIC_InitTypeDef NVIC_InitStructure;
;;;278    
;;;279      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;280      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;281      
;;;282    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;283      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;284      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;285      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;286      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;287      NVIC_Init(&NVIC_InitStructure);
;;;288      
;;;289        /* Enable the USB Wake-up interrupt */
;;;290      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
;;;291      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;292      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;293      NVIC_Init(&NVIC_InitStructure);
;;;294      
;;;295    #elif defined(STM32F37X)
;;;296      /* Enable the USB interrupt */
;;;297      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;298      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;299      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;300      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;301      NVIC_Init(&NVIC_InitStructure);
;;;302      
;;;303      /* Enable the USB Wake-up interrupt */
;;;304      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;305      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;306      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;307      NVIC_Init(&NVIC_InitStructure);
;;;308      
;;;309    #else 
;;;310      /* Enable the USB interrupt */
;;;311      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;312      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;313      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;314      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;315      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;316      
;;;317        /* Enable the USB Wake-up interrupt */
;;;318      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;319      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;320      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d5003          STRB     r5,[sp,#3]
;;;321      NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;322      
;;;323    #endif /* STM32L1XX_XD */
;;;324    }
00003c  bd38              POP      {r3-r5,pc}
;;;325    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 129 "D:\\Keil5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 144
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
